<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sockutils.c Source File</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>sockutils.c</h1><a href="sockutils_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2002 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 
00034 
00035 <span class="preprocessor">#include "<a class="code" href="sockutils_8h.html">sockutils.h</a>"</span>
00036 <span class="preprocessor">#include &lt;string.h&gt;</span> <span class="comment">// for strerror</span>
00037 <span class="preprocessor">#include &lt;errno.h&gt;</span>  <span class="comment">// for the errno variable</span>
00038 <span class="preprocessor">#include &lt;stdio.h&gt;</span>  <span class="comment">// for the stderr file</span>
00039 
00054 <span class="comment">// WinSock Initialization</span>
00055 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00056"></a><a class="code" href="sockutils_8c.html#a0">00056</a> <span class="preprocessor"></span><span class="preprocessor">    #define WINSOCK_MAJOR_VERSION 2     </span>
<a name="l00057"></a><a class="code" href="sockutils_8c.html#a1">00057</a> <span class="preprocessor">    #define WINSOCK_MINOR_VERSION 2     </span>
<a name="l00058"></a><a class="code" href="sockutils_8c.html#a5">00058</a> <span class="preprocessor">    int sockcount= 0;                   </span>
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>
00061 <span class="comment">// Some minor differences between UNIX and Win32</span>
00062 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00063"></a><a class="code" href="sockutils_8c.html#a2">00063</a> <span class="preprocessor"></span><span class="preprocessor">    #define SHUT_WR SD_SEND         </span>
<a name="l00064"></a><a class="code" href="sockutils_8c.html#a3">00064</a> <span class="preprocessor">    #define snprintf _snprintf      </span>
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>
00067 
00068 
00069 <span class="comment">/****************************************************</span>
00070 <span class="comment"> *                                                  *</span>
00071 <span class="comment"> * Locally defined functions                        *</span>
00072 <span class="comment"> *                                                  *</span>
00073 <span class="comment"> ****************************************************/</span>
00074 
00075 <span class="keywordtype">int</span> <a class="code" href="group__remote__pri__func.html#a3">sock_ismcastaddr</a>(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *saddr);
00076 
00077 
00078 
00079 <span class="comment">/*</span>
00080 <span class="comment">    \brief Global variable; needed to keep the message due to an error that we want to discard.</span>
00081 <span class="comment">    </span>
00082 <span class="comment">    This can happen, for instance, because we already have an error message and we want to keep </span>
00083 <span class="comment">    the first one.</span>
00084 <span class="comment">*/</span>
<a name="l00085"></a><a class="code" href="sockutils_8c.html#a6">00085</a> <span class="keywordtype">char</span> <a class="code" href="sockutils_8c.html#a6">fakeerrbuf</a>[<a class="code" href="group__remote__pri__struct.html#a56">SOCK_ERRBUF_SIZE</a> + 1];
00086 
00087 
00088 
00089 
00090 
00091 <span class="comment">/****************************************************</span>
00092 <span class="comment"> *                                                  *</span>
00093 <span class="comment"> * Function bodies                                 *</span>
00094 <span class="comment"> *                                                  *</span>
00095 <span class="comment"> ****************************************************/</span>
00096 
00097 
<a name="l00116"></a><a class="code" href="sockutils_8c.html#a8">00116</a> <span class="keywordtype">void</span> <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *caller, <span class="keywordtype">char</span> *string, <span class="keywordtype">int</span> size)
00117 {
00118 <span class="preprocessor">#ifdef WIN32</span>
00119 <span class="preprocessor"></span>    <span class="keywordtype">int</span> retval;
00120     <span class="keywordtype">int</span> code;
00121     <span class="keywordtype">char</span> message[<a class="code" href="group__remote__pri__struct.html#a56">SOCK_ERRBUF_SIZE</a>];
00122     
00123         code= GetLastError();
00124     
00125         retval= FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
00126                       FORMAT_MESSAGE_MAX_WIDTH_MASK,
00127                       NULL, code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
00128                       (LPSTR) message, SOCK_ERRBUF_SIZE, NULL);
00129     
00130         <span class="keywordflow">if</span> (retval == 0)
00131         {
00132             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(string, size, <span class="stringliteral">"%sUnable to get the exact error message"</span>, caller);
00133             <span class="keywordflow">return</span>;
00134         }
00135     
00136         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(string, size, <span class="stringliteral">"%s%s (code %d)"</span>, caller, message, code);
00137 
00138 <span class="preprocessor">#else</span>
00139 <span class="preprocessor"></span>    <span class="keywordtype">char</span> *message;
00140     
00141         message= strerror(errno);
00142         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(string, size, <span class="stringliteral">"%s%s (code %d)"</span>, caller, message, errno);
00143 <span class="preprocessor">#endif</span>
00144 <span class="preprocessor"></span>}
00145 
00146 
00147 
<a name="l00160"></a><a class="code" href="sockutils_8c.html#a9">00160</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a9">sock_init</a>(<span class="keywordtype">char</span> *errbuf)
00161 {
00162 <span class="preprocessor">#ifdef WIN32</span>
00163 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a5">sockcount</a> == 0)
00164     {
00165     WSADATA wsaData;            <span class="comment">// helper variable needed to initialize Winsock</span>
00166 
00167         <span class="comment">// Ask for Winsock version 2.2.</span>
00168         <span class="keywordflow">if</span> ( WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)
00169         {
00170             <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"Failed to initialize Winsock\n"</span>);
00171             WSACleanup();
00172             <span class="keywordflow">return</span> -1;
00173         }
00174     }
00175 
00176     <a class="code" href="sockutils_8c.html#a5">sockcount</a>++;
00177 <span class="preprocessor">#endif</span>
00178 <span class="preprocessor"></span>
00179     <span class="keywordflow">return</span> 0;
00180 }
00181 
00182 
00183 
<a name="l00192"></a><a class="code" href="sockutils_8c.html#a10">00192</a> <span class="keywordtype">void</span> <a class="code" href="group__remote__pri__func.html#a10">sock_cleanup</a>()
00193 {
00194 <span class="preprocessor">#ifdef WIN32</span>
00195 <span class="preprocessor"></span>    <a class="code" href="sockutils_8c.html#a5">sockcount</a>--;
00196     <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a5">sockcount</a> == 0)
00197         WSACleanup();
00198 <span class="preprocessor">#endif</span>
00199 <span class="preprocessor"></span>}
00200 
00201 
00202 
<a name="l00208"></a><a class="code" href="group__remote__pri__func.html#a3">00208</a> <span class="keywordtype">int</span> <a class="code" href="group__remote__pri__func.html#a3">sock_ismcastaddr</a>(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *saddr)
00209 {
00210     <span class="keywordflow">if</span> (saddr-&gt;sa_family == PF_INET)
00211     {
00212         <span class="keyword">struct </span>sockaddr_in *saddr4 = (<span class="keyword">struct </span>sockaddr_in *) saddr;
00213         <span class="keywordflow">if</span> (IN_MULTICAST(ntohl(saddr4-&gt;sin_addr.s_addr))) <span class="keywordflow">return</span> 0;
00214         <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;
00215     }
00216     <span class="keywordflow">else</span>
00217     {
00218         <span class="keyword">struct </span>sockaddr_in6 *saddr6 = (<span class="keyword">struct </span>sockaddr_in6 *) saddr;
00219         <span class="keywordflow">if</span> (IN6_IS_ADDR_MULTICAST(&amp;saddr6-&gt;sin6_addr)) <span class="keywordflow">return</span> 0;
00220         <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;
00221     }
00222 }
00223 
00224 
00225 
<a name="l00254"></a><a class="code" href="sockutils_8c.html#a11">00254</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a11">sock_open</a>(<span class="keyword">struct</span> addrinfo *addrinfo, <span class="keywordtype">int</span> server, <span class="keywordtype">int</span> nconn, <span class="keywordtype">char</span> *errbuf)
00255 {
00256 <a class="code" href="group__remote__struct.html#a12">SOCKET</a> sock;
00257 
00258     sock = socket(addrinfo-&gt;ai_family, addrinfo-&gt;ai_socktype, addrinfo-&gt;ai_protocol);
00259     <span class="keywordflow">if</span> (sock == -1)
00260     {
00261         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"socket(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00262         <span class="keywordflow">return</span> -1;
00263     }
00264 
00265 
00266     <span class="comment">// This is a server socket</span>
00267     <span class="keywordflow">if</span> (server)
00268     {
00269 <span class="preprocessor">#ifdef BSD</span>
00270 <span class="preprocessor"></span>        <span class="comment">// Force the use of IPv6-only addresses; in BSD you can accept both v4 and v6</span>
00271         <span class="comment">// connections if you have a "NULL" pointer as the nodename in the getaddrinfo()</span>
00272         <span class="comment">// This behaviour is not clear in the RFC 2553, so each system implements the</span>
00273         <span class="comment">// bind() differently from this point of view</span>
00274 
00275         <span class="keywordflow">if</span> (addrinfo-&gt;ai_family == PF_INET6)
00276         {
00277         <span class="keywordtype">int</span> on;
00278 
00279             <span class="keywordflow">if</span> (setsockopt(sock, IPPROTO_IPV6, IPV6_BINDV6ONLY, (<span class="keywordtype">char</span> *)&amp;on, <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>)) == -1)
00280             {
00281                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"setsockopt(IPV6_BINDV6ONLY)"</span>);
00282                 <span class="keywordflow">return</span> -1;
00283             }
00284         } 
00285 <span class="preprocessor">#endif</span>
00286 <span class="preprocessor"></span>
00287         <span class="comment">// WARNING: if the address is a mcast one, I should place the proper Win32 code here</span>
00288         <span class="keywordflow">if</span> (bind(sock, addrinfo-&gt;ai_addr, addrinfo-&gt;ai_addrlen) != 0)
00289         {
00290             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"bind(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00291             <span class="keywordflow">return</span> -1;
00292         }
00293 
00294         <span class="keywordflow">if</span> (addrinfo-&gt;ai_socktype == SOCK_STREAM)
00295             <span class="keywordflow">if</span> (listen(sock, nconn) == -1)
00296             {
00297                 <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"listen(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00298                 <span class="keywordflow">return</span> -1;
00299             }
00300 
00301         <span class="comment">// server side ended</span>
00302         <span class="keywordflow">return</span> sock;
00303     }
00304     <span class="keywordflow">else</span>    <span class="comment">// we're the client</span>
00305     {
00306         <span class="keywordflow">if</span> (connect(sock, addrinfo-&gt;ai_addr, addrinfo-&gt;ai_addrlen) == -1)
00307         {
00308             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"Is libpcap/WinPcap properly installed on the other host? connect() failed: "</span>, errbuf, SOCK_ERRBUF_SIZE);
00309             closesocket(sock);
00310             <span class="keywordflow">return</span> -1;
00311         }
00312 
00313         <span class="keywordflow">return</span> sock;
00314     }
00315 }
00316 
00317 
00318 
00319 
<a name="l00334"></a><a class="code" href="sockutils_8c.html#a12">00334</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a12">sock_close</a>(SOCKET sock, <span class="keywordtype">char</span> *errbuf)
00335 {
00336     <span class="comment">// SHUT_WR: subsequent calls to the send function are disallowed. </span>
00337     <span class="comment">// For TCP sockets, a FIN will be sent after all data is sent and </span>
00338     <span class="comment">// acknowledged by the Server.</span>
00339     <span class="keywordflow">if</span> (shutdown(sock, SHUT_WR) )
00340     {
00341         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"shutdown(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00342         <span class="comment">// close the socket anyway</span>
00343         closesocket(sock);
00344         <span class="keywordflow">return</span> -1;
00345     }
00346 
00347     closesocket(sock);
00348     <span class="keywordflow">return</span> 0;
00349 }
00350 
00351 
00352 
00353 
00354 
00355 
<a name="l00386"></a><a class="code" href="sockutils_8c.html#a13">00386</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a13">sock_validaddr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *address, <span class="keyword">const</span> <span class="keywordtype">char</span> *port,
00387                             <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **addrinfo, <span class="keywordtype">char</span> *errbuf)
00388 {
00389 <span class="keywordtype">int</span> retval;
00390     
00391     retval = getaddrinfo(address, port, hints, addrinfo);
00392     <span class="keywordflow">if</span> (retval != 0)
00393     {
00394         <span class="comment">// if the getaddrinfo() fails, you have to use gai_strerror(), instead of using the standard</span>
00395         <span class="comment">// error routines (WSAGetLastError() in Win32 anderrono in UNIX)</span>
00396         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"getaddrinfo() %s"</span>, gai_strerror(retval));
00397         <span class="keywordflow">return</span> -1;
00398     }
00404     <span class="comment">// This software only supports PF_INET and PF_INET6.</span>
00405     <span class="keywordflow">if</span> (( (*addrinfo)-&gt;ai_family != PF_INET) &amp;&amp; ( (*addrinfo)-&gt;ai_family != PF_INET6))
00406     {
00407         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"getaddrinfo(): socket type not supported"</span>);
00408         <span class="keywordflow">return</span> -1;
00409     }
00410 
00411     <span class="keywordflow">if</span> ( ( (*addrinfo)-&gt;ai_socktype == SOCK_STREAM) &amp;&amp; (<a class="code" href="group__remote__pri__func.html#a3">sock_ismcastaddr</a>( (*addrinfo)-&gt;ai_addr) == 0) )
00412     {
00413         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"getaddrinfo(): multicast addresses are not valid when using TCP streams"</span>);
00414         <span class="keywordflow">return</span> -1;
00415     }
00416 
00417     <span class="keywordflow">return</span> 0;
00418 }
00419 
00420 
00421 
<a name="l00443"></a><a class="code" href="sockutils_8c.html#a14">00443</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a14">sock_send</a>(SOCKET socket, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *errbuf)
00444 {
00445 <span class="keywordtype">int</span> nsent;
00446 
00447 send:
00448 <span class="preprocessor">#ifdef linux</span>
00449 <span class="preprocessor"></span><span class="comment">/*</span>
00450 <span class="comment">    Another pain... in Linux there's this flag</span>
00451 <span class="comment">    MSG_NOSIGNAL</span>
00452 <span class="comment">        Requests not to send SIGPIPE on  errors  on  stream</span>
00453 <span class="comment">        oriented sockets when the other end breaks the con­</span>
00454 <span class="comment">        nection. The EPIPE error is still returned.</span>
00455 <span class="comment">*/</span>
00456     nsent = send(socket, buffer, size, MSG_NOSIGNAL);
00457 <span class="preprocessor">#else</span>
00458 <span class="preprocessor"></span>    nsent = send(socket, buffer, size, 0);
00459 <span class="preprocessor">#endif</span>
00460 <span class="preprocessor"></span>
00461     <span class="keywordflow">if</span> (nsent == -1)
00462     {
00463         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"send(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00464         <span class="keywordflow">return</span> -1;
00465     }
00466 
00467     <span class="keywordflow">if</span> (nsent != <a class="code" href="gencode_8c.html#a27">size</a>)
00468     {
00469         <a class="code" href="gencode_8c.html#a27">size</a>-= nsent;
00470         buffer+= nsent;
00471         <span class="keywordflow">goto</span> send;
00472     }
00473 
00474     <span class="keywordflow">return</span> 0;
00475 }
00476 
00477 
<a name="l00524"></a><a class="code" href="sockutils_8c.html#a15">00524</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a15">sock_bufferize</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *tempbuf, <span class="keywordtype">int</span> *offset, <span class="keywordtype">int</span> totsize, <span class="keywordtype">int</span> checkonly, <span class="keywordtype">char</span> *errbuf)
00525 {
00526 
00527     <span class="keywordflow">if</span> ((*<a class="code" href="gencode_8c.html#a30">offset</a> + <a class="code" href="gencode_8c.html#a27">size</a>) &gt; totsize)
00528     {
00529         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"Not enough space in the temporary send buffer."</span>);
00530         <span class="keywordflow">return</span> -1;
00531     };
00532 
00533     <span class="keywordflow">if</span> (!checkonly)
00534         memcpy(tempbuf + (*offset), buffer, size);
00535 
00536     (*offset)+= <a class="code" href="gencode_8c.html#a27">size</a>;
00537 
00538     <span class="keywordflow">return</span> 0;
00539 }
00540 
00541 
00542 
<a name="l00566"></a><a class="code" href="sockutils_8c.html#a16">00566</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a16">sock_recv</a>(SOCKET sock, <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *errbuf)
00567 {
00568 <span class="keywordtype">int</span> nread;
00569 <span class="keywordtype">int</span> totread= 0;
00570     <span class="comment">// We can obtain the same result using the MSG_WAITALL flag</span>
00571     <span class="comment">// However, this is not supported by recv() in Win32</span>
00572 
00573     <span class="keywordflow">if</span> (<a class="code" href="gencode_8c.html#a27">size</a> == 0)
00574     {
00575         <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"I have been requested to read zero bytes"</span>, 1);
00576         <span class="keywordflow">return</span> 0;
00577     }
00578 
00579 again:
00580     nread= recv(sock, &amp;(buffer[totread]), size - totread, 0);
00581 
00582     <span class="keywordflow">if</span> (nread == -1)
00583     {
00584         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"recv(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00585         <span class="keywordflow">return</span> -1;
00586     }
00587 
00588     <span class="keywordflow">if</span> (nread == 0)
00589     {
00590         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"The other host terminated the connection."</span>);
00591         <span class="keywordflow">return</span> -1;
00592     }
00593 
00594     totread+= nread;
00595 
00596     <span class="keywordflow">if</span> (totread != <a class="code" href="gencode_8c.html#a27">size</a>)
00597         <span class="keywordflow">goto</span> again;
00598 
00599     <span class="keywordflow">return</span> totread;
00600 }
00601 
00602 
00603 
<a name="l00635"></a><a class="code" href="sockutils_8c.html#a17">00635</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a17">sock_recv_dgram</a>(SOCKET sock, <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *errbuf)
00636 {
00637 <span class="keywordtype">int</span> nread;
00638 
00639     nread= recv(sock, buffer, size, 0);
00640 
00641     <span class="keywordflow">if</span> (nread == -1)
00642     {
00643         <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"recv(): "</span>, errbuf, SOCK_ERRBUF_SIZE);
00644         <span class="keywordflow">return</span> -1;
00645     }
00646 
00647     <span class="keywordflow">return</span> nread;
00648 }
00649 
00650 
<a name="l00672"></a><a class="code" href="sockutils_8c.html#a18">00672</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a18">sock_discard</a>(SOCKET sock, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *errbuf)
00673 {
00674 <span class="preprocessor">#define TEMP_BUF_SIZE 65536</span>
00675 <span class="preprocessor"></span>
00676 <span class="keywordtype">char</span> buffer[TEMP_BUF_SIZE];     <span class="comment">// network buffer, to be used when the message is discarded</span>
00677 
00678     <span class="comment">// A static allocation avoids the need of a 'malloc()' each time we want to discard a message</span>
00679     <span class="comment">// Our feeling is that a buffer if 65536 is enough for mot of the application;</span>
00680     <span class="comment">// in case this is not enough, the "while" loop discards the message by calling the </span>
00681     <span class="comment">// sockrecv() several times.</span>
00682 
00683     <span class="keywordflow">while</span> (<a class="code" href="gencode_8c.html#a27">size</a> &gt; TEMP_BUF_SIZE)
00684     {
00685         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sock, buffer, TEMP_BUF_SIZE, errbuf) == -1)
00686             <span class="keywordflow">return</span> -1;
00687         <a class="code" href="gencode_8c.html#a27">size</a>-= TEMP_BUF_SIZE;
00688     }
00689 
00690     <span class="comment">// If there is still data to be discarded</span>
00691     <span class="comment">// In this case, the data can fit into the temporaty buffer</span>
00692     <span class="keywordflow">if</span> (size)
00693     {
00694         <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a16">sock_recv</a>(sock, buffer, size, errbuf) == -1)
00695             <span class="keywordflow">return</span> -1;
00696     }
00697 
00698     <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(<span class="stringliteral">"I'm currently discarding data\n"</span>, 1);
00699 
00700     <span class="keywordflow">return</span> 0;
00701 }
00702 
00703 
00704 
<a name="l00726"></a><a class="code" href="sockutils_8c.html#a19">00726</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a19">sock_check_hostlist</a>(<span class="keywordtype">char</span> *hostlist, <span class="keyword">const</span> <span class="keywordtype">char</span> *sep, <span class="keyword">struct</span> sockaddr_storage *from, <span class="keywordtype">char</span> *errbuf)
00727 {
00728     <span class="comment">// checks if the connecting host is among the ones allowed</span>
00729     <span class="keywordflow">if</span> (<a class="code" href="fileconf_8c.html#a0">hostlist</a>[0])
00730     {
00731     <span class="keywordtype">char</span> *token;                    <span class="comment">// temp, needed to separate items into the hostlist</span>
00732     <span class="keyword">struct </span>addrinfo *addrinfo, *ai_next;
00733     <span class="keywordtype">char</span> *temphostlist;
00734 
00735         temphostlist= (<span class="keywordtype">char</span> *) malloc (strlen(hostlist) + 1);
00736         <span class="keywordflow">if</span> (temphostlist == NULL)
00737         {
00738             <a class="code" href="sockutils_8c.html#a8">sock_geterror</a>(<span class="stringliteral">"sock_check_hostlist(), malloc() failed"</span>, errbuf, SOCK_ERRBUF_SIZE);
00739             <span class="keywordflow">return</span> -1;
00740         }
00741         
00742         <span class="comment">// The problem is that strtok modifies the original variable by putting '0' at the end of each token</span>
00743         <span class="comment">// So, we have to create a new temporary string in which the original content is kept</span>
00744         strcpy(temphostlist, hostlist);
00745 
00746         token= strtok(temphostlist, sep);
00747 
00748         <span class="keywordflow">while</span>( token != NULL )
00749         {
00750         <span class="keyword">struct </span>addrinfo hints;
00751         <span class="keywordtype">int</span> retval;
00752 
00753             addrinfo = NULL;
00754             memset(&amp;hints, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> addrinfo) );
00755             hints.ai_family = PF_UNSPEC;
00756             hints.ai_socktype= SOCK_STREAM;
00757     
00758             retval = getaddrinfo(token, <span class="stringliteral">"0"</span>, &amp;hints, &amp;addrinfo);
00759             <span class="keywordflow">if</span> (retval != 0)
00760             {
00761                 <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"getaddrinfo() %s"</span>, gai_strerror(retval));
00762                 <a class="code" href="group__remote__pri__struct.html#a51">SOCK_ASSERT</a>(errbuf, 1);
00763 
00764                 <span class="comment">// Get next token</span>
00765                 token = strtok( NULL, sep);
00766                 <span class="keywordflow">continue</span>;
00767             }
00768 
00769             <span class="comment">// ai_next is required to preserve the content of addrinfo, in order to deallocate it properly</span>
00770             ai_next= addrinfo;
00771             <span class="keywordflow">while</span>(ai_next)
00772             {
00773                 <span class="keywordflow">if</span> (<a class="code" href="sockutils_8c.html#a20">sock_cmpaddr</a>(from, (<span class="keyword">struct</span> sockaddr_storage *) ai_next-&gt;ai_addr) == 0)
00774                 {
00775                     free(temphostlist);
00776                     <span class="keywordflow">return</span> 0;
00777                 }
00778 
00779                 <span class="comment">// If we are here, it means that the current address does not matches</span>
00780                 <span class="comment">// Let's try with the next one in the header chain</span>
00781                 ai_next= ai_next-&gt;ai_next;
00782             }
00783 
00784             freeaddrinfo(addrinfo);
00785             addrinfo= NULL;
00786             <span class="comment">// Get next token</span>
00787             token = strtok( NULL, sep);
00788         }
00789 
00790         <span class="keywordflow">if</span> (addrinfo)
00791         {
00792             freeaddrinfo(addrinfo);
00793             addrinfo= NULL;
00794         }
00795 
00796         <a class="code" href="sockutils_8c.html#a3">snprintf</a>(errbuf, SOCK_ERRBUF_SIZE, <span class="stringliteral">"The host is not in the allowed host list. Connection refused."</span>);
00797         free(temphostlist);
00798         <span class="keywordflow">return</span> -1;
00799     }
00800 
00801     <span class="keywordflow">return</span> 0;
00802 }
00803 
00804 
<a name="l00823"></a><a class="code" href="sockutils_8c.html#a20">00823</a> <span class="keywordtype">int</span> <a class="code" href="sockutils_8c.html#a20">sock_cmpaddr</a>(<span class="keyword">struct</span> sockaddr_storage *first, <span class="keyword">struct</span> sockaddr_storage *second)
00824 {
00825     <span class="keywordflow">if</span> (first-&gt;ss_family == second-&gt;ss_family)
00826     {
00827         <span class="keywordflow">if</span> (first-&gt;ss_family == AF_INET)
00828         {
00829             <span class="keywordflow">if</span> (memcmp(     &amp;(((<span class="keyword">struct</span> sockaddr_in *) first)-&gt;sin_addr), 
00830                             &amp;(((<span class="keyword">struct</span> sockaddr_in *) second)-&gt;sin_addr),
00831                             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr) ) == 0)
00832                                 <span class="keywordflow">return</span> 0;
00833         }
00834         <span class="keywordflow">else</span> <span class="comment">// address family is AF_INET6</span>
00835         {
00836             <span class="keywordflow">if</span> (memcmp(     &amp;(((<span class="keyword">struct</span> sockaddr_in6 *) first)-&gt;sin6_addr), 
00837                             &amp;(((<span class="keyword">struct</span> sockaddr_in6 *) second)-&gt;sin6_addr),
00838                             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr) ) == 0)
00839                                 <span class="keywordflow">return</span> 0;
00840         }
00841     }
00842 
00843     <span class="keywordflow">return</span> -1;
00844 }
00845 
</pre></div>
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2003 Politecnico di Torino. All rights reserved.</p>
